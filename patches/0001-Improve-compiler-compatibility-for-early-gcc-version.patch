From 2bebae86de6fa7fb9c9c2da9b1f92244da81cd22 Mon Sep 17 00:00:00 2001
From: Marcel Greter <marcel.greter@ocbnet.ch>
Date: Mon, 9 Jan 2017 17:52:00 +0100
Subject: [PATCH 1/3] Improve compiler compatibility for early gcc versions

---
 src/ast.cpp        |  4 +--
 src/ast.hpp        | 10 +++---
 src/color_maps.cpp |  2 +-
 src/context.cpp    |  8 ++---
 src/emitter.cpp    |  2 +-
 src/eval.cpp       | 33 +++++++++++---------
 src/expand.cpp     |  5 +--
 src/extend.cpp     |  5 +--
 src/functions.cpp  | 77 +++++++++++++++++++++++++++++++++++++++++-----
 src/parser.cpp     |  3 +-
 src/subset_map.cpp |  2 +-
 11 files changed, 110 insertions(+), 41 deletions(-)

diff --git a/src/ast.cpp b/src/ast.cpp
index 56d2a8bf..11b675e8 100644
--- a/src/ast.cpp
+++ b/src/ast.cpp
@@ -168,7 +168,7 @@ namespace Sass {
 
   bool Compound_Selector::has_parent_ref() const
   {
-    for (Simple_Selector_Obj s : *this) {
+    for (Simple_Selector_Obj s : elements()) {
       if (s && s->has_parent_ref()) return true;
     }
     return false;
@@ -176,7 +176,7 @@ namespace Sass {
 
   bool Compound_Selector::has_real_parent_ref() const
   {
-    for (Simple_Selector_Obj s : *this) {
+    for (Simple_Selector_Obj s : elements()) {
       if (s && s->has_real_parent_ref()) return true;
     }
     return false;
diff --git a/src/ast.hpp b/src/ast.hpp
index f3ea5364..2cc1de2e 100644
--- a/src/ast.hpp
+++ b/src/ast.hpp
@@ -369,7 +369,7 @@ namespace Sass {
     : elements_(ExpressionMap(s)),
       list_(std::vector<Expression_Obj>()),
       hash_(0), duplicate_key_(NULL)
-    { elements_.reserve(s); list_.reserve(s); }
+    { list_.reserve(s); reset_duplicate_key(); }
     virtual ~Hashed();
     size_t length() const                  { return list_.size(); }
     bool empty() const                     { return list_.empty(); }
@@ -1481,7 +1481,7 @@ namespace Sass {
       if (hash_ == 0) {
         hash_ = std::hash<std::string>()(name());
         for (auto argument : arguments()->elements())
-          hash_combine(hash_, argument->hash());
+        { hash_combine(hash_, argument->hash()); }
       }
       return hash_;
     }
@@ -1573,9 +1573,9 @@ namespace Sass {
       if (hash_ == 0) {
         hash_ = std::hash<double>()(value_);
         for (const auto numerator : numerators)
-          hash_combine(hash_, std::hash<std::string>()(numerator));
+        { hash_combine(hash_, std::hash<std::string>()(numerator)); }
         for (const auto denominator : denominators)
-          hash_combine(hash_, std::hash<std::string>()(denominator));
+        { hash_combine(hash_, std::hash<std::string>()(denominator)); }
       }
       return hash_;
     }
@@ -1759,7 +1759,7 @@ namespace Sass {
     {
       if (hash_ == 0) {
         for (auto string : elements())
-          hash_combine(hash_, string->hash());
+        { hash_combine(hash_, string->hash()); }
       }
       return hash_;
     }
diff --git a/src/color_maps.cpp b/src/color_maps.cpp
index 129e47c5..25da6887 100644
--- a/src/color_maps.cpp
+++ b/src/color_maps.cpp
@@ -613,7 +613,7 @@ namespace Sass {
   Color_Ptr_Const name_to_color(const std::string& key)
   {
     // case insensitive lookup.  See #2462
-    std::string lower{key};
+    std::string lower(key);
     std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
 
     auto p = names_to_colors.find(lower.c_str());
diff --git a/src/context.cpp b/src/context.cpp
index d65e1093..4695e7fd 100644
--- a/src/context.cpp
+++ b/src/context.cpp
@@ -100,10 +100,10 @@ namespace Sass {
     collect_plugin_paths(c_options.plugin_paths);
 
     // load plugins and register custom behaviors
-    for(auto plug : plugin_paths) plugins.load_plugins(plug);
-    for(auto fn : plugins.get_headers()) c_headers.push_back(fn);
-    for(auto fn : plugins.get_importers()) c_importers.push_back(fn);
-    for(auto fn : plugins.get_functions()) c_functions.push_back(fn);
+    for(auto plug : plugin_paths) { plugins.load_plugins(plug); }
+    for(auto fn : plugins.get_headers()) { c_headers.push_back(fn); }
+    for(auto fn : plugins.get_importers()) { c_importers.push_back(fn); }
+    for(auto fn : plugins.get_functions()) { c_functions.push_back(fn); }
 
     // sort the items by priority (lowest first)
     sort (c_headers.begin(), c_headers.end(), sort_importers);
diff --git a/src/emitter.cpp b/src/emitter.cpp
index 6fcb6a17..827e3492 100644
--- a/src/emitter.cpp
+++ b/src/emitter.cpp
@@ -112,7 +112,7 @@ namespace Sass {
 
   char Emitter::last_char()
   {
-    return wbuf.buffer.back();
+    return *wbuf.buffer.rbegin();
   }
 
   // append a single char to the buffer
diff --git a/src/eval.cpp b/src/eval.cpp
index a02d1e56..5c31e1db 100644
--- a/src/eval.cpp
+++ b/src/eval.cpp
@@ -337,15 +337,16 @@ namespace Sass {
     // try to use generic function
     if (env->has("@warn[f]")) {
 
-      // add call stack entry
-      ctx.callee_stack.push_back({
+      struct Sass_Callee callee = {
         "@warn",
         w->pstate().path,
         w->pstate().line + 1,
         w->pstate().column + 1,
         SASS_CALLEE_FUNCTION,
         { env }
-      });
+      };
+      // add call stack entry
+      ctx.callee_stack.push_back(callee);
 
       Definition_Ptr def = Cast<Definition>((*env)["@warn[f]"]);
       // Block_Obj          body   = def->block();
@@ -384,15 +385,16 @@ namespace Sass {
     // try to use generic function
     if (env->has("@error[f]")) {
 
-      // add call stack entry
-      ctx.callee_stack.push_back({
+      struct Sass_Callee callee = {
         "@error",
         e->pstate().path,
         e->pstate().line + 1,
         e->pstate().column + 1,
         SASS_CALLEE_FUNCTION,
         { env }
-      });
+      };
+      // add call stack entry
+      ctx.callee_stack.push_back(callee);
 
       Definition_Ptr def = Cast<Definition>((*env)["@error[f]"]);
       // Block_Obj          body   = def->block();
@@ -428,15 +430,16 @@ namespace Sass {
     // try to use generic function
     if (env->has("@debug[f]")) {
 
-      // add call stack entry
-      ctx.callee_stack.push_back({
+      struct Sass_Callee callee = {
         "@debug",
         d->pstate().path,
         d->pstate().line + 1,
         d->pstate().column + 1,
         SASS_CALLEE_FUNCTION,
         { env }
-      });
+      };
+      // add call stack entry
+      ctx.callee_stack.push_back(callee);
 
       Definition_Ptr def = Cast<Definition>((*env)["@debug[f]"]);
       // Block_Obj          body   = def->block();
@@ -1008,14 +1011,15 @@ namespace Sass {
       bind(std::string("Function"), c->name(), params, args, &ctx, &fn_env, this);
       Backtrace here(backtrace(), c->pstate(), ", in function `" + c->name() + "`");
       exp.backtrace_stack.push_back(&here);
-      ctx.callee_stack.push_back({
+      struct Sass_Callee callee = {
         c->name().c_str(),
         c->pstate().path,
         c->pstate().line + 1,
         c->pstate().column + 1,
         SASS_CALLEE_FUNCTION,
         { env }
-      });
+      };
+      ctx.callee_stack.push_back(callee);
 
       // eval the body if user-defined or special, invoke underlying CPP function if native
       if (body /* && !Prelexer::re_special_fun(name.c_str()) */) {
@@ -1049,14 +1053,15 @@ namespace Sass {
 
       Backtrace here(backtrace(), c->pstate(), ", in function `" + c->name() + "`");
       exp.backtrace_stack.push_back(&here);
-      ctx.callee_stack.push_back({
+      struct Sass_Callee callee = {
         c->name().c_str(),
         c->pstate().path,
         c->pstate().line + 1,
         c->pstate().column + 1,
         SASS_CALLEE_C_FUNCTION,
         { env }
-      });
+      };
+      ctx.callee_stack.push_back(callee);
 
       To_C to_c;
       union Sass_Value* c_args = sass_make_list(params->length(), SASS_COMMA);
@@ -1178,7 +1183,7 @@ namespace Sass {
       List_Obj ll = SASS_MEMORY_NEW(List, l->pstate(), 0, l->separator());
       // this fixes an issue with bourbon sample, not really sure why
       // if (l->size() && Cast<Null>((*l)[0])) { res += ""; }
-      for(Expression_Obj item : *l) {
+      for(Expression_Obj item : l->elements()) {
         item->is_interpolant(l->is_interpolant());
         std::string rl(""); interpolation(ctx, rl, item, into_quotes, l->is_interpolant());
         bool is_null = Cast<Null>(item) != 0; // rl != ""
diff --git a/src/expand.cpp b/src/expand.cpp
index 020fce8c..dae10b95 100644
--- a/src/expand.cpp
+++ b/src/expand.cpp
@@ -715,14 +715,15 @@ namespace Sass {
     Arguments_Obj args = Cast<Arguments>(rv);
     Backtrace new_bt(backtrace(), c->pstate(), ", in mixin `" + c->name() + "`");
     backtrace_stack.push_back(&new_bt);
-    ctx.callee_stack.push_back({
+    struct Sass_Callee callee = {
       c->name().c_str(),
       c->pstate().path,
       c->pstate().line + 1,
       c->pstate().column + 1,
       SASS_CALLEE_MIXIN,
       { env }
-    });
+    };
+    ctx.callee_stack.push_back(callee);
 
     Env new_env(def->environment());
     env_stack.push_back(&new_env);
diff --git a/src/extend.cpp b/src/extend.cpp
index 5348e5dc..d315f96b 100644
--- a/src/extend.cpp
+++ b/src/extend.cpp
@@ -1936,7 +1936,7 @@ namespace Sass {
           recseen.insert(cur->head());
           // create a copy since we add multiple items if stuff get unwrapped
           Compound_Selector_Obj cpy_head = SASS_MEMORY_NEW(Compound_Selector, cur->pstate());
-          for (Simple_Selector_Obj hs : *cur->head()) {
+          for (Simple_Selector_Obj hs : cur->head()->elements()) {
             if (Wrapped_Selector_Obj ws = Cast<Wrapped_Selector>(hs)) {
               ws->selector(SASS_MEMORY_CLONE(ws->selector()));
               if (Selector_List_Obj sl = Cast<Selector_List>(ws->selector())) {
@@ -2085,7 +2085,8 @@ namespace Sass {
     // we set `extended` flag on extended selectors
     if (b->is_root()) {
       // debug_subset_map(subset_map);
-      for(auto const &it : subset_map.values()) {
+      auto values = subset_map.values();
+      for(auto it : values) {
         Complex_Selector_Ptr sel = NULL;
         Compound_Selector_Ptr ext = NULL;
         if (it.first) sel = it.first->first();
diff --git a/src/functions.cpp b/src/functions.cpp
index 8b2f962e..50b0666e 100644
--- a/src/functions.cpp
+++ b/src/functions.cpp
@@ -30,6 +30,24 @@
 #include "wincrypt.h"
 #endif
 
+#if defined __GNUC__ && ! defined __llvm__
+  #define GCC_VERSION (__GNUC__ * 10000 \
+                       + __GNUC_MINOR__ * 100 \
+                       + __GNUC_PATCHLEVEL__)
+  #if GCC_VERSION < 40500
+    #include <tr1/random>
+    #define IMPLEMENT_TR1
+    #define tr1ns std::tr1
+    #define uniform_real_distribution uniform_real
+  #else
+    #include <random>
+    #define tr1ns std
+  #endif
+#else
+  #include <random>
+  #define tr1ns std
+#endif
+
 #define ARG(argname, argtype) get_arg<argtype>(argname, env, sig, pstate, backtrace)
 #define ARGM(argname, argtype, ctx) get_arg_m(argname, env, sig, pstate, backtrace, ctx)
 #define ARGNR(argname) get_arg_nr(argname, env, sig, pstate, backtrace)
@@ -303,9 +321,43 @@ namespace Sass {
     // random_device degrades sharply once the entropy pool
     // is exhausted. For practical use, random_device is
     // generally only used to seed a PRNG such as mt19937.
-    static std::mt19937 rand(static_cast<unsigned int>(GetSeed()));
+    static tr1ns::mt19937 rand(static_cast<unsigned int>(GetSeed()));
+
+    tr1ns::uniform_real_distribution<> std_dist(0, 1);
+    #ifdef IMPLEMENT_TR1
+      tr1ns::variate_generator <
+        tr1ns::mt19937,
+        tr1ns::uniform_real_distribution <double>
+      > gen_std_dist(rand, std_dist);
+    #endif
+
+    // Using ULONG_MAX here seems to fail on Mac OSX Clang!?
+    tr1ns::uniform_real_distribution<> full_dist(0, 4294967296);
+    #ifdef IMPLEMENT_TR1
+      tr1ns::variate_generator <
+        tr1ns::mt19937,
+        tr1ns::uniform_real_distribution <double>
+      > gen_full_dist(rand, full_dist);
+    #endif
+
+    // helper function to retrieve a random number in interval
+    // works around some compiler issues with older gcc versions
+    static double random(double min, double max)
+    {
+      tr1ns::uniform_real_distribution<> distributor(min, max);
+      #ifdef IMPLEMENT_TR1
+        tr1ns::variate_generator <
+          tr1ns::mt19937,
+          tr1ns::uniform_real_distribution <>
+        > gen(rand, distributor);
+        distributor(rand);
+        return gen();
+      #else
+        return distributor(rand);
+      #endif
+    }
 
-    // features
+    // supported features lookup table
     static std::set<std::string> features {
       "global-variable-shadowing",
       "extend-selector-pseudoclass",
@@ -1269,13 +1321,19 @@ namespace Sass {
           err << "Expected $limit to be an integer but got " << lv << " for `random'";
           error(err.str(), pstate);
         }
-        std::uniform_real_distribution<> distributor(1, lv + 1);
-        uint_fast32_t distributed = static_cast<uint_fast32_t>(distributor(rand));
+        // std::uniform_real_distribution<> distributor(1, lv + 1);
+        // uint_fast32_t distributed = static_cast<uint_fast32_t>(distributor(rand));
+        uint_fast32_t distributed = random(1, lv + 1);
         return SASS_MEMORY_NEW(Number, pstate, (double)distributed);
       }
       else if (b) {
-        std::uniform_real_distribution<> distributor(0, 1);
-        double distributed = static_cast<double>(distributor(rand));
+        // std::uniform_real_distribution<> distributor(0, 1);
+        // double distributed = static_cast<double>(distributor(rand));
+        #ifdef IMPLEMENT_TR1
+          double distributed = gen_std_dist();
+        #else
+          double distributed = std_dist(rand);
+        #endif
         return SASS_MEMORY_NEW(Number, pstate, distributed);
       } else if (v) {
         throw Exception::InvalidArgumentType(pstate, "random", "$limit", "number", v);
@@ -2053,8 +2111,11 @@ namespace Sass {
     BUILT_IN(unique_id)
     {
       std::stringstream ss;
-      std::uniform_real_distribution<> distributor(0, 4294967296); // 16^8
-      uint_fast32_t distributed = static_cast<uint_fast32_t>(distributor(rand));
+      #ifdef IMPLEMENT_TR1
+        uint_fast32_t distributed = gen_full_dist();
+      #else
+        uint_fast32_t distributed = full_dist(rand);
+      #endif
       ss << "u" << std::setfill('0') << std::setw(8) << std::hex << distributed;
       return SASS_MEMORY_NEW(String_Quoted, pstate, ss.str());
     }
diff --git a/src/parser.cpp b/src/parser.cpp
index 279e116c..7c2343bf 100644
--- a/src/parser.cpp
+++ b/src/parser.cpp
@@ -327,7 +327,7 @@ namespace Sass {
     do {
       while (lex< block_comment >());
       if (lex< quoted_string >()) {
-        to_import.push_back(std::pair<std::string,Function_Call_Obj>(std::string(lexed), 0));
+        to_import.push_back(std::pair<std::string,Function_Call_Obj>(std::string(lexed), (Function_Call*) NULL));
       }
       else if (lex< uri_prefix >()) {
         Arguments_Obj args = SASS_MEMORY_NEW(Arguments, pstate);
@@ -2978,6 +2978,7 @@ namespace Sass {
     if (left_subpos && ellipsis_left) left = ellipsis + left.substr(left_subpos);
     if (right_subpos && ellipsis_right) right = right.substr(right_subpos) + ellipsis;
     // now pass new message to the more generic error function
+    if (source == NULL || *source == 0) source = pstate.src;
     error(msg + prefix + quote(left) + middle + quote(right), pstate);
   }
 
diff --git a/src/subset_map.cpp b/src/subset_map.cpp
index 24513e49..a83de97d 100644
--- a/src/subset_map.cpp
+++ b/src/subset_map.cpp
@@ -24,7 +24,7 @@ namespace Sass {
         continue;
       }
       const std::vector<std::pair<Compound_Selector_Obj, size_t> >& subsets = hash_[(*sel)[i]];
-      for (const std::pair<Compound_Selector_Obj, size_t>& item : subsets) {
+      for (const auto& item : subsets) {
         bool include = true;
         for (const Simple_Selector_Obj& it : item.first->elements()) {
           auto found = dict.find(it);
-- 
2.21.0.windows.1

